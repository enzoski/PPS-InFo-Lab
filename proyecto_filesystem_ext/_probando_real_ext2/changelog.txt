[12/02/2021 - 28/02/2021] V1: Hice las 4 clases que representan a las estructuras parseables de ext2: superblock, group descriptor, inode y directory entry. Hice una primera prueba de parseo pero faltaria definir el tema de los getters y setters y las funciones que defini al final de 'superblock' e 'inode'.

[28/02/2021 - 08/03/2021] V2: Tuve la primera revision junto con Bruno, y quedamos que saquemos el metodo '_parse' y directamente parseemos en el '__init__()' (constructor). Por lo de los setters y getters, me dio a entender que lo siga haciendo como crea que es mejor (si quiero conservar los binarios en los atributos [setter] y luego mostrarlos [getter] de alguna forma en especial, ok), y ya luego cuando este probando el programa, si veo que convendria cambiar algo, lo haga. Y podría hacer un .py aparte donde reuna todas las pruebas que le haga a las clases, lo que el llama un 'rolling test'. [Terminé el parseo de todas las estructuras, salvo algunos campos del superbloque que quedó en 'veremos'. Y faltaría ver el tema de las fechas que se guardan en la hora local y no en UTC-0].

(semana de estudio para un final)

[17/03/2021 - 19/04/2021] V3: Hice la clase 'Ext2' que se comunica con las demas clases (superblock, group descriptor, inode y directory entry) para recorrer y parsear un filesystem ext2 real (podremos abrir archivos y directorios, leer inodos, leer bloques, etc...). Tambien hice la clase 'Directory' que se encarga de recorrer los bloques de datos (directos e indirectos) apuntados por inodos que representan directorios, para así ir parseando los directory entries y generar una lista de archivos, la cual se puede ver haciendo print(objeto_directorio), o de forma completa: print(objeto_directorio.show_dentries()). Y también hice la clase 'FileHandle' que se encarga de justamente manejar a un archivo de datos, es decir, poder hacer 'read', 'seek', 'tell'... Para esto, primero obtiene todos los número de bloque de datos asignados a un archivo del filesystem, o sea, es similar a lo que hace Directory, pero como los datos de un archivo no tienen 'estructura', no se parsea nada dentro de los bloques (igual despues hubo que implementar el 'read' jeje). En ambos casos se van parseando los punteros que hay en los bloques directos e indirectos (la clave está en estos ultimos) del inodo que representa al archivo/directorio.

A modo de resumen, lo que logré con este proyecto es:
* Poder parsear las estructuras internas de un filesystem ext2 (superbloque, tabla de descriptores de grupo, tabla de inodos y entradas de directorio), es decir, identificar los bytes que conforman esas estructuras dentro del filesystem, y 'extraer' de ellos su significado (hay que casos que la 'traduccion' es directa a un numero decimal, como contadores o tamaños, y otras en que cada bit significa algo que lo mostraremos como un string u otro tipo, como los privilegios/permisos de acceso a un archivo).
* Poder abrir archivos y directorios de un filesystem ext2, dado su path absoluto.
* Poder ver los archivos y/o directorios que "contiene" un directorio (y tambien, más a bajo nivel, ver sus entradas de directorio).
* Poder hacer las operaciones básicas sobre un archivo: 'read', 'seek', 'tell' y 'close' ('write' no).
* Poder ver la representacion del inodo asociado a un archivo o directorio, mediante 'show_inode()'.
* Poder explorar los bytes de cada bloque y de cada inodo del filesystem, mediante los metodos 'read_block' y 'read_inode'. O tambien una determinada cantidad de bytes mediante 'read_record'.

Podría definirlo como un cuasi-driver del filesystem ext2.

Nota: al final, el journal de ext3 quedó pendiente de parsear.


----------------------------------------------------------------

[01/05/2021] V3.5: Arreglé la forma de leer los bytes de un inodo, ya que pensaba que siempre su estructura era de 128 bytes, pero realmente depende de la revision de ext2 que tengamos (Rev 0: 128 bytes, Rev >= 1: >=128 bytes, siendo una potencia perfecta de 2 y menor o igual al tamaño de bloque). Yo sigo parseando unicamente 128 bytes (en inode.py), que son los bytes base de todo inodo, pero ahora la cantidad de bytes leidos del disco no siempre son 128 bytes, sino que depende de lo que nos diga el superbloque, él es quien almacena el tamaño en disco de un inodo (128 bytes, 256, etc...). De esta manera se leerán correctamente los bytes de cada inodo, porque sino habría un desfasaje y podríamos estar leyendo un inodo dentro de los limites de otro, cosa que al momento del parseo dará inconsistencias.

[03/08/2021] V4: Me puse a mejorar el tema del manejo de timestamps. Ext2 hace uso de timestamps en los inodos (fechas de archivos y directorios) y en el superbloque (fechas generales del filesystem). Los timestamps se basan en el Tiempo Unix, que se define como la cantidad de segundos que pasaron desde la Unix Epoch (1/1/1970 00:00:00 UTC+0) hasta el día de hoy. Por ende, los bytes que se escriben en el filesystem representan segundos. Yo lo que hacia antes era tomar esos segundos y convertirlos a la zona horaria actual (en mi caso UTC-3), haciendo uso de objetos DateTime que nos ofrece la librería estandar de Python. Pero se ve que los bytes (segundos) ya se escriben en base a la zona horaria de la PC que provocó un cambio en algún timestamp, por lo que si yo al parsearlos los convierto, estaría volviendo a agregarle o sacarle horas segun corresponda (en mi caso, le volvería a restar 3 horas). Entonces para que no ocurra esta inconsistencia, ahora almaceno las fechas como vienen, leo los bytes y armo el objeto DateTime como si fuera en UTC+0. Lo unico es que no sabremos realmente en qué zona horaria estará esa fecha, salvo que sepamos en qué PC se escribieron dichos bytes, pero bueno, de esta forma estaremos mostrando fechas más fieles a la realidad.
Además, en los 'getters' de timestamps ahora verifico la validez de la fecha que almacenamos con el 'setter'; si es > 1/1/1970 entonces devuelvo el objeto DateTime, sino devuelvo 'None'. Y en el gran 'print' de las estructuras de inodo y superbloque, las fechas 'None' se muestran como 'Not defined'.
También, arreglé el campo 's_checkinterval' del superbloque, para que muestre justamente una duración de tiempo en vez de una fecha.
Y por otro lado, puse los rolling test en una carpeta 'test' y agregué unos programas que comparan archivos para testear las salidas de los rolling test y de los códigos fuente (esto ultimo por si por ejemplo fuese necesario comparar archivos entre 2 repos).